#include "stdafx.h"

// ========================================================
//	정점 셰이더 단계 (Vertex Shader, VS)
// ========================================================

/*
	- 입력 조립기 단계에서 조힙된 정점들이 정점 셰이더 단계에 사용된다.
	- 변환, 조명, 변위 매핑 등 수많은 특수 효과를 정점 셰이더 단계에서 할 수 있다.
*/

// ========================================================
//	국소 공간과 세계 공간
// ========================================================

/*
	- 좌표계는 세계 공간(World Space)와 국소 공간(Local Space)가 존재한다.
	- 국소 공간이 존재하는 이유는 해당 물체를 원점에 두고 좌표축에 맞게 정렬할 수 있기 때문이다.
	- 국소 좌표계를 전역 좌표계로 변경하는 과정을 세계 변환(World Transform)이라하고 해당 변환 행렬을 (World Matrix)라고 한다.
	- 모든 오브젝트는 국소 공간에서 세계 공간으로 변환하면 모든 오브젝트는 동일한 공간 좌표 기준으로 배치할 수 있게 된다.

	국소 좌표계 장점
		 1. 오브젝트의 중심은 원점이며 해당 주축에 따라 위, 앞, 옆을 판단할 수 있다.
		 2. 오브젝트를 재사용하는 경우 한개의 원점 좌표를 이용하여 그 오브젝트들의 세계 좌표로 변환하는 것이 효율적이다.
		 3. 오브젝트를 정점과 색인 자료를 중복하는 것은 낭비이기 때문에, 하나의 국소 공간을 기준으로 인스턴스마다 위치, 방향, 비례를 적절하게 다르게 설정하여 그리는 것이 효울적이다. (인스턴싱(Instancing) 기법)  

	공간 행렬
		- 월드 공간 기준 국소 공간 위치 Qw = (Qx, Qy, Qz, 1)과 국소 공간에서의 오브젝트 위치 x, y, z를 각각 Uw = (Ux, Uy, Uz), Vw = (Vx, Vy, Vz), Ww = (Wx, Wy, Wz)라고 했을 때 월드 공간 기준 오브젝트 위치를 행렬로 표현할 수 있다.

		국소 공간 오브젝트를 월드 공간으로 이동한 행렬
				  ┌ Ux Uy Uz 0 ┐
			W =   | Vx Vy Vz 0 |
				  | Wx Wy Wz 0 |
				  └ Qx Qy Qz 1 ┘

		- 이러한 것은 직관적이지 않기 때문에 W = SRT로 정의한다.
		- S는 크기, R는 회전, T는 이동을 의미한다.
		- 즉, 오브젝트가 세계 공간에서 크기, 방향, 위치을 이용하면 월드 행렬을 구할 수 있다.

		국소 공간 오브젝트를 월드 공간에 배치한 행렬 (W = SRT)
			- S : 한변의 길이가 2, R : xz 평면에서 시계방향으로 45º 회전, T : 국소 공간의 월드 공간 좌표의 (10, 0, 10)
				
				┌ 2 0 0 0 ┐		   ┌ √2/2 0 -√2/2 0 ┐		 ┌ 1  0 0  0 ┐
			S :	| 0 1 0 0 |	   R : |   0  1    0  0 |    T : | 0  1 0  0 |
			    | 0 0 2 0 |        | √2/2 0  √2/2 0 |		 | 0  0 1  0 |
				└ 0 0 0 1 ┘		   └   0  0    0  1 ┘        └ 10 0 10 1 ┘

					  ┌ √2 0 -√2 0 ┐
			W = SRT = | 0  1  0  0 |
					  | √2 0 √2  0 |
					  └ 10 0 10  1 ┘

			세계 변환후 국소 공간의 좌표 축
				- Uw = (√2, 0, -√2, 0)
				- Vw = (0, 1, 0, 0)
				- Ww = (√2, 0, √2, 0)
				- Qw = (10, 0, 10, 1)
*/

// ========================================================
//	시야 공간
// ========================================================

/*
	- 세계를 관찰자가 볼 수 있도록 카메라를 월드에 배치를 한다. 
	- 카메라 기준의 공간을 시야 공간(View Space), 시점 공간 (Eye Space), 카메라 공간 (Camera Space)라고 한다.
	- 시야 공간에서는 카메라가 바라보는 위치는 z축, 위쪽은 Y축, 오른쪽은 x축이다.
	- 세계 공간에서 시야 공간으로 바꾸는 것을 시야 변환(View Transform)이라 하고 그 변환 행렬을 시야 행렬 (View Matrix)라고 한다.

	월드 공간에서 시야 공간 변환
		- 시야 행렬로 바꾸기 위해서는 월드 행렬의 역행렬을 구하면 된다. 
		- 역행렬을 구할 때는 월드 공간의 원점 위치에서 위치와 방향만 바뀌었기 때문에 V = W⁻¹ = (RT)⁻¹로 구할 수 있다.

		월드 공간에서 시야 공간으로 바꾸기 위한 행렬

		V = W⁻¹ = (RT)⁻¹ = T⁻¹R⁻¹ = T⁻¹Rᵀ

			┌  1   0   0  0 ┐ ┌  Ux Vx Wx 0 ┐		┌  Ux   Vx   Wx  0 ┐
		=   |  0   1   0  0 | |  Uy Yy Wy 0 |   =   |  Uy   Yy   Wy  0 |
			|  0   0   1  0 | |  Uz Yz Wz 0 |		|  Uz   Yz   Wz  0 |
			└ -Qx -Qy -Qz 1 ┘ └  0  0  0  1 ┘		└ -Qºu -Qºv -Qºw 1 ┘



		- 다음으로 월드 기준으로 카메라의 축 방향을 구해야 한다.

		카메라 축 구하는 방법
			
			        카메라가 바라보는 위치 - 카메라 위치 
			w = --------------------------------------------
			      ||카메라가 바라보는 위치 - 카메라 위치||

				  카메라 z축 X 월드 y축 
			u = ------------------------------
				  ||카메라 z 축 X 월드 y축||
			
			v = 카메라 z축 X 카메라 x축

		- v를 구할 때는 무조건 단위 벡터가 나오기 때문에 정규화할 필요가 없다.
*/

using namespace DirectX;

namespace Sample
{
	// 월드 공간에서 사야 공간으로 바꿔주는 함수
	XMMATRIX XMMatrixLookAtLH(
		FXMVECTOR EyePosition,		// 카메라의 위치
		FXMVECTOR FocusPosition,	// 카메라가 바라보는 위치
		FXMVECTOR UpDirection);		// 세계 상향 벡터 (거의 항상 (0, 1, 0)이다.)

	// XMMatrixLookAtLH 사용 예
	XMVECTOR pos = XMVectorSet(5, 3, -10, 1.0f);		// 카메라를 (5, 3, -10)에 설치
	XMVECTOR target = XMVectorZero();					// 세계 공간의 원점을 바라봄
	XMVECTOR up = XMVectorSet(0.0f, 1.0f, 0.0f, 0.0f);	// 세계 상향 벡터

  //XMMATRIX V = Sample::XMMatrixLookAtLH(pos, target, up);
}

// ========================================================
//	투영과 동차 절단 공간
// ========================================================

/*
	- 카메라는 카메라가 바라보는 공간 영역이 존재한다.
	- 카메라의 공간은 절두체(Frustum) 모형이다.
	- 카메라는 절두체 안에 있는 3차원 구조를 2차원으로 투영(Projection)한다.

	원근 투영 (Perspective Projection)
		- 시점에서 물체의 정점까지 이은 선을 정점의 투영선(Line of Projection)이라고 부른다.
		- 원근 투영은 물체에서 나온 투영 선이 2차원 투영 창과 만나 생기는 물체 상을 만드는 과정이다.

	절두체의 정의
		- 시야 절두체의 구성은 가까운 평면, 먼 평면, 수직 시야각, 종횡비(Aspect Ratio)가 존재한다.
		- 가까운 평면과 먼 평면은 카메라가 바라보는 방향의 수직인 평면이다.

		종횡비
			- 종횡비는 "투영 창 너비 / 투영 창 높이"이다.
			- 투영 창은 후면 버퍼에 입력되기 때문에 후면 버퍼의 종횡비와 같도록 투영창의 종횡비를 설정해야 한다.
			- 투영 창과 후면 버퍼의 종횡비가 일치하지 않으면 출력되는 이미지가 왜곡될 수 있다.

		수평 시야각
			- 수평 시야각은 카메라가 보는 절두체의 영역 중 수평에 해당되는 시야각이다.
			- 수직 시야각과 종횡비로 구할 수 있다.
			- 수평 시야각을 구하는 식은 "투영 창 높이 / 종횡비"이다.

		투영 창 거리
			- tan(수직 시야각 / 2) = 1 / d => d = cot(수직 시야각 / 2)

			투영 창 거리로 수평 시야각 구하기
				tan(수평 시야각 / 2) = 종횡비 / 투영창 거리 = 종횡비 / cot(수직 시야각 / 2) = 종횡비 * tan(수직 시야각 / 2) 

				∴ 수평 시야각 = 2tan⁻¹(종횡비 * tan(수직 시야각 / 2))

		정점의 투영
			- 정점을 투영 창에 투영했을 때 정점의 위치를 비례를 이용하면 구할 수 있음
			
			정점 투영 시 정점의 위치
				- 기존 위치 : (x, y, z), 투영 위치 : (x', y', 투영 창 거리)

				x' / 투영창 거리 = x / z => x' = 투영창 거리 * x / z = x * cot(수직 시야각 / 2) / 2 = x / ztan(수직 시야각 / 2)
				y' / 투영창 거리 = y / z => y' = 투영창 거리 * y / z = x * cot(수직 시야각 / 2) / 2 = y / ztan(수직 시야각 / 2)

				- 종횡비 <= x' <= 종횡비, -1 <= y' <= 1, 가까운 평면 <= z <= 먼 평면

		정규화된 장치 좌표(NDC)
			- 투영 창의 종횡비에 의존해야 한다는 문제가 있어 개션이 필요
			- 종횡비 의존을 없애기 위해서 정점을 투영 후 정점의 x 좌표를 -1 ~ 1 범위로 정규화해야 한다.
			- 이러한 투영 후 x, y 좌표를 정규화된 장치 좌표(Normalized Device Corrdinates)라고 한다.

			절두체 범위
				- -1 <= x'/종횡비 <= 1, -1 <= y' <= 1, 가까운 평면 <= z <= 먼 평면

			- 시야 공간에서 NDC 공간으로 변환하는 것을 일종으 단위 변환(Unit Conversion)으로 볼 수 있다.
			- x축에서 NDC의 한 단위는 시야 공간의 종횡비 단위와 같다.

			NDC 공간의 투영 좌표
				x' = x / (종횡비 * ztan(수직 시야각 / 2)
				y' = y / (ztan(수직 시야각 / 2)

		투영 변환을 행렬로 표현
			- 투영된 위치를 하나의 데이터로 표현하기 위해 행렬로 만들어여 한다.
			- 행렬로 만들 때 각 좌표 값은 다른 좌표 값에 영향을 받지않아야 한다.
			- 그렇기 때문에 이전 구한 식의 x'과 y'은 z가 있기 때문에 z좌표를 정규화해야 한다.
			
			투영 변환 행렬 z좌표 정규화
				1. 먼저 z좌표를 정규화하기 전 나중에 z좌표가 필요하기 때문에 사용하지 않는 행렬 위치인 [2][3]에 z를 저장한다.
				2. [3][3]을 0을 저장한다.
				3. x'과 y'에 x를 곱해 정규화를 한다.

					┌  1/종횡비tan(수직 시야각 / 2)   0               0  0 ┐
				P = |               0       1/tan(수직 시야각 / 2)   0  0 |
					|               0                 0             A  1 |
					└			    0                 0			    B  0 ┘

			투영 변환 행렬에서 투형 변환으로 만들기
				1. 투영 변환 행렬에서 [x, y, z, 1]를 곱한다.
				2. 이전 [2][3]에 저장한 값인 z로 나눠준다.

				1번 결과
				[x / 종횡비tan(수직 시야각 / 2), y / tan(수직 시야각 / 2), Az + B, z]

				2번 결과
				[x / 종횡비ztan(수직 시야각 / 2), y / ztan(수직 시야각 / 2), A + B / z, 1]

			- 가까운 평면은 0보다 크므로 "가까운 평면 <= z <= 먼 평면"식에 의해 z는 0보다 크다.
			- 이때 w 값으로 나누어 정규화하는 것을 원근 나누기(Perspective Divide) 또는 동차 나누기 (Homogeneous Divide)라고 한다.

		정규화된 깊이 값
			- 앞에서 구한 z값은 깊이 버퍼링 알고리즘에 사용하기 위해서 값을 계속 저장한다.
			- DirectX 3D에서 깊이 성분을 0 ~ 1구간을 사용하기 떄문에 z값도 정규화 해야 한다.
			- 정규화하기 위해서 깊이 갚들의 상대적 관계를 유지하는 순서 보존 함수를 만들어야 한다.
			
			순서 보존 함수 제작법
				1. 가까운 평면일 때 깊이 성분은 0, 먼 평면일 때 깊이 성분은 1이여야 한다.
				2. 앞에서 구한 투형 변환 정규화한 z 좌표를 이용하며 조건을 구한다.

				식 1 : g(가까운 평면) = A + B / 가까운 평면 = 0
				식 2 : g(먼 평면) = A + B / 먼 평면 = 1

				식 1 활용 :
						A + B / 가까운 평면 = 0 => A = -B / 가까운 평면

				식 2 :
						식 1 활용 값 대입 => A + -A * 가까운 평면 / 먼 평면 = 1
						(A * 먼 평면 - A * 가까운 평면) / 먼 평면 = 1
						A * 먼 평면 - A * 가까운 평면 = 먼 평면
						A = 먼 평면 / (먼 평면 - 가까운 평면)

				g(z) = A + B / z에 대입
				∴ g(z) = 먼 평면 / (먼 평면 - 가까운 평면) - (가까운 평면 * 먼 평면) / (먼 평면 - 가까운 평면) * z

			- 순서 보존 함수는 z에 따른 0 ~ 1 사이의 깊이 값은 순증가(Strictly Increasing)한다.
			
			최종적인 원근투영 행렬
				
					┌  1/종횡비tan(수직 시야각 / 2)   0                           0                        0 ┐
				P = |               0       1/tan(수직 시야각 / 2)               0                        0 |
				    |               0                 0            먼 평면 / 먼 평면 - 가까운 평면          1 |
					└			    0                 0    -가까운 평면 * 먼 평면 / (먼 평면 - 가까운 평면)  0 ┘

			- 원근 나누기 전의 기하구조를 동차 절단 공간(Homogenous Clip Space), 원근 나누기 후의 기하구조를 NDC 공간에 있다고 한다.

		XMMatrixPersectiveForLH
			- 원근투영 행렬을 구축해주는 함수
 */				

namespace Sample
{
	// 원근투영 행렬을 반환하는 함수
	XMMATRIX XMMatrixPerspectiveForLH(
		FLOAT FovAngleY,	// 수직 시야각 (라디안 단위)
		FLOAT AspectRatio,	// 종횡비 = 너비 / 높이
		FLOAT NearZ,		// 가까운 평면까지의 거리
		FLOAT FarZ			// 먼 평면까지의 거리
	);

  //XMMATRIX pM = Sample::XMMatrixPerspectiveForLH(0.25f * 3.14, DX3DApp::AspectRatio(), 1.0f, 1000.0f);
}