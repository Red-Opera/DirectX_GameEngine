#include "stdafx.h"

// ========================================================
//	Direct3D의 개요
// ========================================================

/*
	개요
		- DirectX 3D는 3차원 세계를 렌더링할 수 있게 하는 저수준의 API
		
		- 그래픽 하드웨어를 제어할 수 있는 소프트웨어 인터페이스를 제공
		- 그래픽 하드웨어와 응용 프로그램 사이에 존재하여 하드웨어의 세부적인 내용을 알 필요 X
*/		

// ========================================================
//	COM (Component Object Model)
// ========================================================

// DirectX에서 프로그래밍 언어 독립성(다양한 프로그래밍 언어로 작성된 컴포넌트들이 함께 사용)과 하위 호환성(이전 버전의 호환)을 가능하게 하는 기술

/*
	COM 인터페이스
		- new 키워들 생성하지 않는다.
		- delete가 아닌 Release로 삭제한다.
		- IUnknown이라는 인터페이스를 상속받아 이러한 메소드가 사용 가능함
		- 대문자 I로 시작 (ex : ID3D11Texture2D)
*/

// ========================================================
//	텍스처 및 자료 자원 형식
// ========================================================

/*
	텍스처
		- 2차원 텍스처는 이미지 자료를 저장하는 것으로, 텍스처의 각 원소는 한 픽셀의 색상을 담는다.
		- 2차원 텍스처는 법선 매핑이라는 3차원 벡터를 저장하는데 사용과같이 범용적으로 사용된다.

		- 텍스처는 2차원뿐만이 아니라 1차원 및 3차원 등 다양한 차원이 존재하며 특정 형식에 맞춰 자료를 담는다.

	자료 자원 형식
		- 텍스처의 형식은 DXGI_FORMAT이라는 열거형로 지정한다.
		- DXGI_FORMAT 형식에서 RGBA는 각각 빨강, 녹색, 파란색, 알파값을 의미한다.
		- DXGI_FORMAT 형식에서 RGBA는 색상뿐만이 아니라 3차원 백터를 담을 수 있다.

		- DXGI_FORMAT 형식
			1. DXGI_FORMAT_R32G32B32_FLOAT : 각 원소는 32비트 float형 3개로 구성
			2. DXGI_FORMAT_R16G616B16A16_UNORM : 각 원소는 0 ~ 1 구간으로 구성되는 16비트 4개로 구성
			3. DXGI_FORMAT_R32G32_UINT : 각 원소는 32비트 unsigned int형 2개로 구성
			4. DXGI_FORMAT_R8G8B8A8_UNORM : 각 원소는 0 ~ 1 구간으로 구성되는 8비트 4개로 구성
			5. DXGI_FORMAT_R8G8B8A8_SNORM : 각 원소는 -1 ~ 1 구간으로 구성되는 8비트 4개로 구성
			6. DXGI_FORMAT_R8G8B8A8_SINT : 각 원소는 -128 ~ 127 구간으로 구성되는 8비트 4개로 구성
			7. DXGI_FORMAT_R8G8B8A8_UINT : 각 원소는 0 ~ 255 구간으로 구성되는 8비트 4개로 구성
			8. DXGI_FORMAT_R8G8B8A8_TYPELESS : 무형식 텍스쳐 형식으로 메모리만 확보하고 나중에 지정할 때 사용
*/

// ========================================================
//	교환 사슬과 페이지 교환
// ========================================================

/*
	- 연속적인 출력할 때 생기는 깜빡이는 현상을 방지하기 위한 방법
	- 애니메이션의 한 프레임을 화면 밖에 그리는 텍스처로 해결하며 이러한 텍스처를 후면 버퍼(Back Buffer)라고 한다.
	- 주어진 한 프레임을 후면 버퍼에 그린 다음, 완전한 프레임을 사용자에게 표시한다.
	
	페이지 교환
		- 버퍼링을 구현할 때는 두 개의 텍스처 버퍼를 이용한다.
		- 화면에 표시되는 버퍼를 전면 버퍼(Front Buffer), 화면 밖에 그리는 버퍼를 후면 버퍼(Back Buffer)라고 한다.
		- 전면 버퍼는 화면에 표시하고 후면 버퍼는 다음 프레임을 그리는 역할을 하며 다음 프레임으로 넘어갈 때 역할을 바꾼다.
		- 다음 프레임으로 넘어갈때 전면 버퍼는 후면 버퍼, 후면 버퍼는 전면 버퍼가 된다.
		- 버퍼끼리 교환하여 화면에 표시하는 것을 제시(presenting)이라고 한다.
		- 버퍼를 바꿀 때는 전면 버퍼와 후면 버퍼의 포인터만 바꾼다.
		- 전면과 후면을 사용하는 것을 이중 버퍼링(Double Buffering)이라고 한다.
		- 전면과 후면과 같이 2개 버퍼만 사용하는 것이 아니라 3개도 사용할 수 있으며 일반적으로 2개 버퍼로 충분하다.

	교환 사슬
		- 전면 버퍼와 후면 버퍼는 하나의 교환 사슬(Swap Chain)을 형성한다.
		- DirectX 3D에서는 IDXGISwapChain이라는 인터페이스를 대표한다.
		- IDXGISwapChain은 전면 버퍼 텍스처와 후면 버퍼 텍스터를 담으며 버퍼 크기 변경, 버퍼의 제시를 할 수 있도로 해준다.
*/

// ========================================================
//	깊이 버퍼링
// ========================================================

/*
	- 깊이 버퍼(Depth Buffer)는 각 픽셀의 깊이 정보를 담는 텍스처이다.
	- 픽셀 깊이는 0.0 ~ 1.0까지의 값으로, 0.0은 관찰자와 최대한 가까이 있는 픽셀이고 1.0은 가장 먼 픽셀이다.
	- 깊이 버퍼 원소들과 후면 버퍼 픽셀은 1대1 대응으로, 후면 버퍼의 해상도가 1280x1024인 경우 깊이 버퍼도 1280x1024의 원소들로 구성된다.
	- 깊이 버퍼도 텍스처이므로 자료 형식을 지정해야 한다.
	- 스텐실 버퍼는 반드시 사용하는 것을 아님

	- 깊이 버퍼링 텍스처 형식
		1. DXGI_FORMAT_D32_FLOAT_S8X24_UINT : 각 텍셀(텍스처 픽셀)은 32비트 float형 깊이 값과 0 ~ 255 구간 정수 스텐실 값(스텐실 버퍼에 사용)과 24비트 padding으로 구성되는 형식
		2. DXGI_FORMAT_D32_FLOAT : 각 텍셀은 32비트 float형 형식
		3. DXGI_FORMAT_D24_UNORM_S8_UINT : 각 텍셀은 0 ~ 1 구간의 부호 없는 24비트 깊이 값과 8비트의 unsigned int형식의 정수 스텐실로 구성
		4. DXGI_FORMAT_D16_UNORM : 각 텍셀은 0 ~ 1 구간으로 부호 없는 16비트 깊이 값으로 구성

	
	- DirectX 3D에서는 깊이 버퍼링 또는 z-버퍼링을 이용하여 물체들 간의 앞과 뒤를 구분함
	- 깊이 버퍼링을 사용함에 따라 물체의 출력 순서는 중요하지 않음
*/

// ========================================================
//	텍스처 자원 뷰
// ========================================================

/*
	텍스쳐 자원 결속과 텍스처 자원
		- 렌더링 파이프라인에서 텍스처를 사용할 수 있도록 하는 단계(결속(Bind) 단계)가 존재한다.
		- 텍스처를 렌더 대상으로 사용 또는 세이더 자원으로 사용하도록 지정할 수 있다.
		- 두가지 모두 사용할 경우 D3D11_BIND_RENDER_TARGET | D3D11_BIND_SHADER_RESOURCE와 같이 결속 플래그(Bind Flag)를 사용하면 된다.

	자원 뷰 (Resource View)
		- 텍스처는 직접 묶지 않고 텍스처의 자원 뷰(Resource View)를 이용하여 생성한다.
		- 자원 뷰를 생성하는 이유는 형식 점검이 최소화하는 것과 같이 효율성을 향상하기 위함이다.
		- 렌더 대상과 셰이더 자원으로 사용하기 위해서 각각 ID3D11RenderTargetView, ID3D11ShaderResourceView를 이용한다.
		- 자원 뷰는 DirectX 3D에게 자원을 사용하는 방식 (어느 단계에 묶을 것인지), 생성 시점에서 무형식을 지정한 자원 형식의 구체적인 형식을 지정하는 역할을 한다.
		- 무형식 자원인 경우 어느 파이프라인 단계에서는 float, 다른 파이프라인 단계에서는 정수로 사용할 수 있다.

		- 텍스처를 자원 뷰로 묶을 때 결속 플래그를 지정해야 한다. (ex : D3D11_BIND_DEPTH_STENCIL (깊이 버퍼링을 사용하기 위한 결속 플래그))
*/

// ========================================================
//	다중표본화의 이론
// ========================================================

/*
	- 픽셀들의 배열로 근사할 때 생기는 현상을 앨리어싱(Aliasing)이라고 한다.
	- 계단 현상을 없앨 수 있는 앨리어싱 제거(AntiAliasing)이라는 기법이 존재한다.

	초과표본화(SuperSampling)
		1. 후면 버퍼와 깊이 버퍼를 화면 해상도보다 4배 (가로 2배, 세로 2배)로 잡음
		2. 3차원 장면을 4배의 해상도로 후면 버퍼에 렌더링 함
		3. 화면에 출력할 때 원래 크기로 환원(Resolving)한다.

		- 환원 공정을 하향 표준화(DownSampling)이라고 한다.
		- 환원 공정은 4픽셀 블록 색상의 평균을 구하여 최종 색상을 구하는 방법을 이용한다.
		- 초과표본화는 픽셀 처리량과 메모리 소모량이 네 배로 증가하기 때문에 비용이 크다.

	다중표본화(MultiSampling)
		- DirectX 3D에서 사용하는 앨리어싱 제거 기법
		- 폴리곤의 외곽선만 안티앨리어싱을 함

		초과표본화와 비교
			1. 공통점
				- 4X 다중표본화는 초과표본화처럼 화면 해상도의 4배인 후면 버퍼와 깊이 버퍼를 사용한다.

			2. 차이점
				- 초과표본화보다 비용이 적다.
*/

// ========================================================
//	DirectX 3D의 다중 표본화
// ========================================================

/*
	- DirectX 3D에서 다중표본화를 하기위해서는 DXGI_SAMPLE_DESC라는 구조체를 작성해야 한다.

	DXGI_SAMPLE_DESC 맴버
		- Count : 픽셀당 추출할 표본의 개수
		- Quality : 원하는 품질 수준

	- 표본 개수 또는 수준이 높을수록 렌더링 비용이 증가한다.
*/

namespace Sample
{
	// DXGI_SAMPLE_DESC의 구성
	typedef struct DXGI_SAMPLE_DESC {
		UINT Count;
		UINT Quality;
	} DXGI_SAMPLE_DESC, * LPDXGI_SAMPLE_DESCS;
}

/*
	- 다중표준화의 품질수준을 확인하기 위해 ID3D11Device::CheckMultisampleQualityLevels을 사용한다.
	- 품질 수준을 정하는 기준은 텍스처의 형식과 표본의 개수이다.

	ID3D11Device::CheckMultisampleQualityLevels 매개변수 구성
		- DXGI_FORMAT format : 다중표준화를 확인할 텍스처의 형식
		- UINT SampleCount : 픽셀당 사용할 샘플의 개수
		- UINT *pNumQualityLevels : 주어진 매개변수에 대한 품질 수준 개수를 반환할 변수

	- 반환 값이 클수록 더 높은 수준의 다중표준화로 나타남
	- 입력한 매개변수로 장치가 지원하지 않은 경우 0을 반환함
	- 하나의 텍스처 형식과 표본 개수 조함으로 유효한 품질 수준의 범위는 0 ~ *pNumQualityLeves - 1까지

	- 보통 합리적으로 표본을 4개 또는 8개로 지정
	- 다중표본화를 하지 않을 경우 표본 개수를 1, 품질 수준을 0으로 지정하면 된다.
*/

// ========================================================
//	기능 수준
// ========================================================

/*
	- DirectX11 3D의 기능 수준(Feature Level)은 그래픽 디바이스가 지원하는 기능 수준을 정의한 것
	- enum 값에 있는 원소 중 0번부터 차례대로 그래픽 디바이스가 각 기능을 지원하는지 확인
	- 만약 해당 원소의 기능을 그래픽 디바이스가 지원하지 않을 경우 다음 원소 기능 수준을 지원하는지 확인한다.
	- 기능 수준을 0번부터 확인하기 떄문에 가장 최신 기능부터 작성한다.
*/

namespace Sample
{
	// D3D_FEATURE_LEVEL 구성
	typedef enum D3D_FEATURE_LEVEL
	{
		D3D_FEATURE_LEVEL_9_1 = 0x9100,
		D3D_FEATURE_LEVEL_9_2 = 0x9200,
		D3D_FEATURE_LEVEL_9_3 = 0x9300,
		D3D_FEATURE_LEVEL_10_0 = 0xa000,
		D3D_FEATURE_LEVEL_10_1 = 0xa100,
		D3D_FEATURE_LEVEL_11_0 = 0xb000,
	} D3D_FEATURE_LEVEL;
}

namespace Sample2
{
	// D3D_FEATURE_LEVEL 지원하는 기능 수준 작성법
	D3D_FEATURE_LEVEL featureLevels[4] =
	{
		D3D_FEATURE_LEVEL_11_0,
		D3D_FEATURE_LEVEL_10_1,
		D3D_FEATURE_LEVEL_10_0,
		D3D_FEATURE_LEVEL_9_3
	};
}